<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Christian Wittmann">
<meta name="dcterms.date" content="2024-06-21">

<title>chrwittm.github.io - How LLMs are Trained</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GF3YYKQQNH"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-GF3YYKQQNH', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  });
});
</script> 
  
<script src="../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">chrwittm.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/chrwittm" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/chrwittm" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.kaggle.com/christianwittmann" rel="" target=""><i class="bi bi-file-earmark-code" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">How LLMs are Trained</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">llm</div>
                <div class="quarto-category">nlp</div>
                <div class="quarto-category">training</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Christian Wittmann </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 21, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Large Language Models (LLMs) like ChatGPT have become invaluable tools for many of us. But what lies beneath the surface of these sophisticated models? How have they been trained to deliver such a seemingly magical experience? In this blog post, we will conceptually explore the training methods used for LLMs and dive into some details. In line with Jeremy Howard’s <a href="https://www.youtube.com/watch?v=jkrNMKz9pWU">Hackers’ Guide to Language Models</a> [1], our journey begins with the foundational <a href="https://arxiv.org/abs/1801.06146">ULMFit Paper</a> [2], which introduced a three-step approach to language model training. After a brief detour into tokenization, we will examine how this three-step approach is implemented today by analyzing the LLaMA papers and other sources. By exploring the different phases, you will gain a deeper understanding of the inner mechanics of large language model training and build intuition on how these models learn a broad range of skills by simply predicting the next token in a sequence of tokens. In conclusion, we will see that today’s large language model training involves at least four steps, with an optional fifth step.</p>
<style>
  figure {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
  }
</style>
<figure class="figure">
<img src="llm-training.png" alt="Dalle: LLM training on vast amounts of text and human feedback" style="width:50%;" class="figure-img">
<figcaption class="figure-caption">
Dalle: LLM training on vast amounts of text and human feedback
</figcaption>
</figure>
<section id="the-ulmfit-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-ulmfit-paper">The ULMFiT Paper</h2>
<p>Today’s approach to training large language models dates back to the 2018 <a href="https://arxiv.org/abs/1801.06146">ULMFit Paper</a> [2] by Jeremy Howard and Sebastian Ruder. They describe a transfer learning approach to natural language processing (NLP). Although the paper’s intention was to train a classifier, such as generating ratings from an IMDb movie review, the approach is remarkably similar to training a large language model today.</p>
<p>The ULMFiT method consists of three main steps:</p>
<ul>
<li><p><strong>Pre-Training</strong>: The language model is trained on a large corpus of text to learn the essence of language, its structure, the meaning of words, and real-world concepts. In the ULMFiT paper, they used the <a href="https://paperswithcode.com/dataset/wikitext-103">Wikitext-103 dataset</a> containing about 100 million tokens of Wikipedia text. Back in the days, this was considered to be large 😉. This phase is not task-specific, instead, it teaches the model general language understanding. Today, this step is still the foundation for training large language models, but the models are trained on significantly larger and more diverse datasets.</p></li>
<li><p><strong>Fine-Tuning</strong>: In this phase, the model is fine-tuned on domain-specific data, such as movie reviews, to learn the specifics of the domain. Originally, this was done using discriminative fine-tuning, where different layers of the model are trained with varying learning rates. This fine-tuning phase conceptually persists in modern language model training, although the training methods have changed to become instruction tuning.</p></li>
<li><p><strong>Classifier Fine-Tuning</strong>: Finally, the model is trained for the specific task, such as classifying movie reviews, using labeled examples. Originally, this was done by adding some final layers to the model and carefully freezing/unfreezing the pre-trained model to prevent it from forgetting its pre-training. Again, this additional fine-tuning step still exists in today’s language model training, but this has become Reinforcement Learning by Human Feedback (RLHF) which fine-tunes a model according to human preference.</p></li>
</ul>
<style>
  figure {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
  }
</style>
<figure class="figure">
<img src="ulmfit-training.png" alt="The 3-step ULMFiT Training Approach" style="width:100%;" class="figure-img">
<figcaption class="figure-caption">
The 3-step ULMFiT Training Approach
</figcaption>
</figure>
</section>
<section id="the-3-steps-of-training-large-language-models" class="level2">
<h2 class="anchored" data-anchor-id="the-3-steps-of-training-large-language-models">The 3 Steps of Training Large Language Models</h2>
<p>While the techniques have evolved, training a large language models today still fits a 3-step approach of pre-training, followed by two fine-tuning steps: Instruction tuning and reinforcement learning by human feedback (RLHF). When you read through the papers or announcements of recent LLMs (<a href="https://openai.com/index/chatgpt">ChatGPT</a> or <a href="https://ai.meta.com/blog/meta-llama-3/">Llama3</a>), you will often find references to pre-training and fine-tuning, but many details are hidden between the lines about the process. The <a href="https://arxiv.org/abs/2307.09288">Llama2 paper</a> [3], not surprisingly due to Meta’s open-source approach, is one of the best resources to read about the process. Andrej Karpathy’s video <a href="https://youtu.be/zjkBMFhNj_g?si=u5xdOeSHC0BjcZ-A">Intro to Large Language Models</a> [4] also excellently explains the different stages of the training process. Let me break it down for you.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<div>
<pre class="mermaid mermaid-js">sequenceDiagram
    participant DP as Data Provider
    participant TP as Training Pipeline
    participant Human as Human Annotator

    %% Step 1: Language Model Pre-Training
    Note over DP,TP: Step 1: Language Model Pre-Training
    DP -&gt;&gt; TP: Provide Large General-Domain Corpus for Pre-Training
    TP --&gt;&gt; DP: Return Pre-Trained Language Model (Foundation Model)

    %% Step 2: Instruction Tuning
    Note over DP,TP: Step 2: Instruction Tuning
    DP -&gt;&gt; TP: Provide Instruction-Focused Corpus for Fine-Tuning
    TP --&gt;&gt; DP: Return Instruction-Tuned Language Model (Assistant Model)

    %% Step 3: Reinforcement Learning with Human Feedback (RLHF)
    Note over DP,Human: Step 3: Reinforcement Learning with Human Feedback (RLHF)
    DP -&gt;&gt; TP: Prompting Instruction-Tuned Language Model
    TP -&gt;&gt; Human: Provide Generated Outputs for Feedback
    Human -&gt;&gt; TP: Provide Feedback on Model Outputs
    TP --&gt;&gt; DP: Return RLHF-Tuned Language Model (Chat Model)
</pre>
</div>
</div>
</div>
</div>
<p>While the 3-step approach is exactly what happens when training an LLM, we need to step back and talk about tokenization first. Since computers / computer scientists start counting at 0 and since the tokenization happens before pre-training, let’s call it “step 0”.</p>
</section>
<section id="step-0-tokenization" class="level2">
<h2 class="anchored" data-anchor-id="step-0-tokenization">Step 0: Tokenization</h2>
<p>You often hear the phrase that “LLMs are trained to predict the next word of a sentence”. This is a convenient simplification we can easily relate to, and we will use this simplification for the rest of this blog post, but let’s face reality for a few sentences: Today’s LLM actually thinks in terms of tokens which can either be letters, a combination of letters or whole words, maybe something like a syllable. Tokens are the building blocks, the atoms of the LLM-generated language, but they also determine the network architecture and they are the currency of LLMs. After all, LLMs API are usually billed based on tokens.</p>
<p>For the purpose of this blog post, we need to understand that the vocabulary of a tokenizer, i.e.&nbsp;the individual tokens, is learned from data. Many tokenizers use Byte Pair Encoding (BPE) to determine which combination of letters is a token. Simplistically said, BPE starts with a vocab consisting of just letters. Then it finds the most common combination of letters and assigns it to a new token. This process is repeated until the size of the vocab (a pre-determined number) is reached.</p>
<p>The vocabulary of a tokenizer determines the capabilities of a model, for example, by including or excluding characters other than the Latin alphabet, an implicit decision about language support is already made. Additionally the vocabulary of the tokenizer is an indicator for how efficient an LLM can be in a language because there is a tradeoff between vocab size and computational efficiency. Very small vocabularies (only letters, for example) are similarly inefficient as having millions of tokens (like all entries of all encyclopedia of all supported languages).</p>
<p>The composition of the vocab already contains information on how language is structured, because the most frequent words get their own tokens. Infrequent or combined words are split up in more than one token or even only letters. The following illustration generated via <a href="https://tiktokenizer.vercel.app/?model=gpt-4">Tiktokenizer</a> show, for example, how “token” is a token, but “tokenization” consists of 2 tokens.</p>
<style>
  figure {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
  }
</style>
<figure class="figure">
<img src="tokenizer-example-crop.png" alt="Tokenization illustrated via Tiktokenizer" style="width:100%;" class="figure-img">
<figcaption class="figure-caption">
Tokenization illustrated via <a href="https://tiktokenizer.vercel.app/?model=gpt-4">Tiktokenizer</a>
</figcaption>
</figure>
<p>Tokenization, however, is a process which needs to be finished before the LLM is trained, because the LLM only learns on tokenized data. Additionally, the size of the vocabulary also influences the network architecture, because for every token of the vocab an embedding is learned during LLM training. These embeddings are numerical representations of the tokens which contain semantic meaning. This is easier imagined for words, and I explained embeddings and their meanings in detail <a href="https://chrwittm.github.io/posts/2024-03-15-embeddings/">in this blog post</a>.</p>
<p>For the remainder of this blog post let’s stick to the <a href="https://youtu.be/wjZofJX0v4M?si=NPDFuuAH_kNrpFf5&amp;t=773">convenient lie</a> [5] that LLMs are next word predictors (not next token predictors) because it makes thinking about LLM training more intuitive. Before we move on to pre-training, one final note on tokenization: The video <a href="https://youtu.be/zduSFxRajkE?si=eOf5uPqkOuKLELPe">Let’s build the GPT Tokenizer</a> by Andrej Karpathy [6] is very accessible for learning more about tokenization.</p>
</section>
<section id="step-1-pre-training" class="level2">
<h2 class="anchored" data-anchor-id="step-1-pre-training">Step 1: Pre-Training</h2>
<p>The first step in training large language models is pre-training. During pre-training, the model “reads” vast amounts of text, in a self-supervised way to learn the following:</p>
<ul>
<li>Grammar and Syntax: Understanding the rules and structure of language.</li>
<li>Semantics: Learning the meanings of words and phrases in various contexts.</li>
<li>World Knowledge: Accumulating general information about the world, which is embedded in the text.</li>
</ul>
<p>This is easily said, but what happens under the hood, i.e., in the net? While the learning mechanisms of babies and LLMs function in completely different ways, you could nonetheless say that LLMs learn about language like children. Children have highly adaptive brains, but they initially know nothing about language. By paying attention to the world around them (and receiving instruction and correction), they learn the meanings of words, the structure of sentences, and grammar — no textbook required. Similarly, LLMs begin with randomly initialized neural networks and are exposed to vast amounts of text. They use mechanisms like the transformer architecture with its attention mechanism to learn grammar and syntax, semantics, and gain world knowledge. Let’s unpack the various aspects of LLM pre-training in the following sections.</p>
<section id="how-large-is-vast" class="level3">
<h3 class="anchored" data-anchor-id="how-large-is-vast">How large is “vast”?</h3>
<p>When we say that during pre-training, the model “reads” vast amounts of text, how large is “vast” actually?</p>
<p>Let’s try a human-centric comparison: How much can a human read in a lifetime compared to the training set of an LLM? For a first reference point, let’s calculate the amount of text a human could read in a lifetime:</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Constants</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>hours_per_day <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>days_per_year <span class="op">=</span> <span class="dv">365</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>reading_speed_wpm <span class="op">=</span> <span class="dv">250</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>average_book_length_words <span class="op">=</span> <span class="dv">85000</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate total number of hours spent reading</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>total_hours_per_year <span class="op">=</span> hours_per_day <span class="op">*</span> days_per_year</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>total_hours <span class="op">=</span> total_hours_per_year <span class="op">*</span> years</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate total number of words read</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>total_minutes <span class="op">=</span> total_hours <span class="op">*</span> <span class="dv">60</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>total_words <span class="op">=</span> total_minutes <span class="op">*</span> reading_speed_wpm</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate total number of books read</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>total_books <span class="op">=</span> total_words <span class="op">/</span> average_book_length_words</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate total number of tokens read (1 token per 0.75 words)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>tokens_per_word <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> <span class="fl">0.75</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>total_tokens <span class="op">=</span> total_words <span class="op">*</span> tokens_per_word</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results with formatted numbers</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Using the parameters defined in the code, a human might read for </span><span class="sc">{</span>total_hours<span class="sc">:,}</span><span class="ss"> hours in a lifetime."</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"To put this into numbers, a human would have read:"</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>total_books<span class="sc">:,</span><span class="fl">.2</span><span class="er">f</span><span class="sc">}</span><span class="ss"> books"</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>total_words<span class="sc">:,}</span><span class="ss"> words"</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span><span class="bu">int</span>(total_tokens)<span class="sc">:,}</span><span class="ss"> tokens"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Using the parameters defined in the code, a human might read for 36,500 hours in a lifetime.
To put this into numbers, a human would have read:
 - 6,441.18 books
 - 547,500,000 words
 - 730,000,000 tokens</code></pre>
</div>
</div>
<p>Let’s compare this to the training data of a large language models. The following table contains data from <a href="https://en.wikipedia.org/wiki/Large_language_model#List">Wikipedia</a> with some additions. It turns out that even the “ancient” GPT-2 was trained on almost an order of magnitude more tokens than a human can read in a lifetime:</p>
<table class="table">
<colgroup>
<col style="width: 8%">
<col style="width: 14%">
<col style="width: 17%">
<col style="width: 25%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Model</th>
<th>Release Date</th>
<th>Parameters</th>
<th>Training Data (tokens)</th>
<th>Multiplier (compared to human)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Human</td>
<td>Ongoing</td>
<td>Incomparable</td>
<td>730 million</td>
<td>1x</td>
</tr>
<tr class="even">
<td>GPT-1</td>
<td>June 2018</td>
<td>117 million</td>
<td>5 billion</td>
<td>6.85x</td>
</tr>
<tr class="odd">
<td>GPT-2</td>
<td>February 2019</td>
<td>1.5 billion</td>
<td>10 billion</td>
<td>13.70x</td>
</tr>
<tr class="even">
<td>GPT-3</td>
<td>June 2020</td>
<td>175 billion</td>
<td>300 billion</td>
<td>410.96x</td>
</tr>
<tr class="odd">
<td>GPT-4</td>
<td>March 2023</td>
<td>Estimated 1.5 trillion</td>
<td>unknown</td>
<td>unknown</td>
</tr>
</tbody>
</table>
<p>The <a href="https://arxiv.org/abs/2302.13971">Llama Paper</a> [7], gives even more insights as llama was trained on publicly available data. The following table shows the model training data, and converting this into tokens, the paper states that <em>“LLaMA-33B and LLaMA-65B were trained on 1.4T tokens. The smaller models were trained on 1.0T tokens.”</em></p>
<style>
  figure {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
  }
</style>
<figure class="figure">
<img src="pre-training-data-llama.png" alt="Pre-training data used to train Meta's llama models" style="width:50%;" class="figure-img">
<figcaption class="figure-caption">
Pre-training data used to train Meta’s llama models (<a href="https://arxiv.org/abs/2302.13971">Source</a>)
</figcaption>
</figure>
<p>State-of-the-art LLMs have therefore seen several orders of magnitude more text than the average human, but what does this actually mean? How can LLMs learn from just reading text?</p>
</section>
<section id="what-does-reading-mean" class="level3">
<h3 class="anchored" data-anchor-id="what-does-reading-mean">What does “reading” mean?</h3>
<p>When we say that a large language model reads text, that is oversimplifying the process. Instead, the training pipeline samples batches from the training set text, and the size of this batch is the context window of the large language model. The text is therefore split up into these batches, each of which is used to train the model on next word prediction. Conveniently, one batch of text can be turned into many training examples by <a href="https://www.youtube.com/watch?v=eMlx5fFNoYc&amp;t=668s">masking different parts of the text</a> [8]. Typically, it is performed like this:</p>
<ul>
<li><strong>Batch</strong>: “The cat sat on the mat”</li>
<li><strong>Training example 1</strong>: “The cat sat on the …”</li>
<li><strong>Training example 2</strong>: “The cat sat on …”</li>
<li><strong>Training example 3</strong>: “The cat sat …”</li>
<li><strong>Training example 4</strong>: “The cat …”</li>
<li><strong>Training example 5</strong>: “The …”</li>
</ul>
<p>For each of these training examples, the model attempts to predict the next word. Although it may not be obvious at first sight, a model needs extensive knowledge to make an accurate prediction. First of all, it needs some understanding of grammar. For example, words like pronouns (“he”, “she”, “it”) would be poor predictions, and while adjectives (“beautiful”, “hard-working”) might make sense in some contexts, they are not ideal here. We are looking for a noun, but not just any noun, “sky” or “idea” would be poor choices. Instead, the model needs to have knowledge about the world to determine that we need a physical object associated with cats (implying that the model can understand what a cat is) and the surrounding context. Therefore, words like “couch”, “bed”, or “mat” are likely candidates. As you can see, the model needs to know quite a bit about the world to make a good prediction.</p>
<p>Conveniently, the actual word the model should predict is known, allowing the model to learn in a self-supervised way by evaluating its predicted word against the actual masked word. The prediction is not just a single word but a probability distribution of all the words in the model’s (i.e.&nbsp;the tokenizer’s) vocabulary. The most likely word in this distribution is chosen as the prediction, check out <a href="https://youtu.be/wjZofJX0v4M?si=7qPUAigM5pXPZand&amp;t=1435">this video from 3Blue1Brown</a> [5] to see it in action.</p>
<p>When calculating the loss (via cross-entropy loss), the model therefore receives nuanced feedback on its performance rather than just a simple right or wrong answer. This feedback helps the model understand how close its prediction was to the actual word, and it can adjust its internal parameters accordingly. This adjustment process, known as gradient descent, updates the model weights via back-propagation to improve future predictions. This means that all the neurons in the many layers of the neural network receive feedback on how well they contributed to the final prediction. This way the model not only learns to predict the exact next word but learns to understand the context and semantics of the language better.</p>
<p>For example, if the model predicted “number” instead of “mat,” the loss would be high, and parameters in the network would receive more significant updates compared to a semantically better prediction like “couch.” In both cases, however, the model learns from its predictions. As the gradients flow back, more semantic meaning is baked into the token embeddings. Additionally, the key and query matrices of the transformer architecture learn about how words are related to each other, enhancing the model’s understanding of language and its semantics.</p>
<p>Summing up this section, “reading” is a lot more than just acknowledging the text. It essentially dissects the text into training examples, and the model learns by trying to predict masked words in the texts.</p>
</section>
<section id="learning-semantics-grammar-and-syntax-and-world-knowledge" class="level3">
<h3 class="anchored" data-anchor-id="learning-semantics-grammar-and-syntax-and-world-knowledge">Learning Semantics, Grammar and Syntax, and World Knowledge</h3>
<p>What exactly happens within the different matrices during gradient descent is basically impossible to grasp, but can we build some intuition on how an LLM can acquire knowledge even though it primarily functions as a next word predictor? Let’s start with the raw embeddings of each token. Even when carefully trained, the meaning of each token remains ambiguous, even when we think in terms of words. A “model,” for instance, can refer to a machine learning model, a fashion model, or a toy.</p>
<p>The transformer architecture and the attention mechanism allow the tokens to “communicate” with each other. Through the key and query matrices, the model learns which words/tokens are more related to each other. However, we should not think about this in the way of a look-up table, but rather that the patterns like adjective-noun relations are learned by the model so that during inference the respective embeddings can be updated. Let’s take the context of “machine learning model”: During training time, the model has learned that some words in certain locations are likely to imprint additional meaning on other words. This knowledge is baked into the LLM so that at inference it can pass on the meaning of “machine learning” to “model”.</p>
<p>The model does not only learn how to update the semantics, but also an understanding of the structure of language starts to emerge. For example, a large language model learns to use the third person “s” when it sees many sentences like “Tom likes chocolate.” However, the LLM does not explicitly learn the rule itself (“In the present tense, add an”s” to verbs when the subject is a singular third person (he, she, it)“). Instead, the model learns to mimic the pattern of the training data by selecting the most likely form of the verb”to like” during inference.</p>
<p>The more training data the model is exposed to and the larger the neural network, the more implicit knowledge the model can store. By reading about chocolate, the model learns that it is usually brownish, contains cocoa and sugar, tastes good, and perhaps some chocolate brands. This is how a model can store knowledge. Again, this is not a look-up table, but the model learns the gestalt of chocolate. Think of it like reading the <a href="https://en.wikipedia.org/wiki/Chocolate">Wikipedia article about chocolate</a>: Neither you nor the LLM can recite the article word-for-word afterwards, but both you and the LLM will have learned something about chocolate. Andrej Karpathy calls this a “<a href="https://youtu.be/zjkBMFhNj_g?si=_uiDKONZduwzoC6I&amp;t=323">lossy compression</a>”, and this is one factor why models hallucinate: They simply pick the most likely next word/token based on what they have read and understood about chocolate. We should not think about the learning process for LLMs as a deterministic process like filling a bunch of database tables with facts, but it is a much softer and subtle process, just like our human learning experience.</p>
<p>Therefore, an LLM can easily continue a prompt like “Chocolate is made of …” based on everything it has learned, and it will likely produce a good answer. However, there is a risk that some information may be inaccurate. As we move into the next training phase, we will get to know strategies on how these risks can be minimized.</p>
<p>Before we move on to the next training stage, we need to talk about the term “Foundation Model”, which is used to describe a model delivered by pre-training. Foundation models are not the models which are used by ChatGPT. Rather, a foundation model can become a chat model, but we still need 2 more training steps (Remember the 3-step training approach!). Nonetheless, the terminology can be confusing because you can select “GTP-3.5” or “GPT-4” as a model in the OpenAI-UI. This, however, only means that the Chat Model you use has been trained on the respective foundation model. Also, please be wary of marketing material which talk about “Foundation Models” because usually they also refer to different types of models. Foundation models have obtained broad knowledge, and they can continue/extent prompts by adding the most likely next word. To create an experience like ChatGPT, a foundation model needs to be fine-tuned further by instruction tuning and reinforcement learning by human feedback (RLHF), the topics we will explore in the next sections.</p>
</section>
</section>
<section id="step-2-instruction-tuning" class="level2">
<h2 class="anchored" data-anchor-id="step-2-instruction-tuning">Step 2: Instruction Tuning</h2>
<p>To transition a foundation model into a practical application like ChatGPT, the next step is instruction tuning. During instruction tuning, the model is introduced to various tasks such as answering questions, summarization, and more. This training helps to transition the model from simply generating text to becoming an assistant. Instruction tuning therefore is a supervised learning process because the dataset consists of labeled data where the responses in the dataset are the labels for the prompts/questions. The following illustration shows an example from the <a href="https://huggingface.co/datasets/Open-Orca/OpenOrca">OpenOrca dataset</a> which builds on the <a href="https://github.com/google-research/FLAN">FLAN collection</a> to illustrate what such a dataset looks like:</p>
<style>
  figure {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
  }
</style>
<figure class="figure">
<img src="openorca.png" alt="Example from the OpenOrca Dataset" style="width:100%;" class="figure-img">
<figcaption class="figure-caption">
Example from the <a href="https://huggingface.co/datasets/Open-Orca/OpenOrca">OpenOrca Dataset</a>
</figcaption>
</figure>
<p>Instruction tuning has been shown in many papers (for example, the <a href="https://arxiv.org/abs/2109.01652">FLAN paper</a> [9]) to lead to better zero-shot performance in tasks like answering questions and summarization compared to the performance of foundation models. Knowing that the performance of foundation models can be significantly improved by using few-shot examples, i.e., demonstrations of how a task should be performed, one way to think about instruction tuning and building some intuition on why it is useful is to imagine it as baking few-shot examples into the foundation model, so you do not need to provide examples all the time.</p>
<p>Since large language models are stateless and cannot learn from conversations (i.e., their model parameters are not updated during use (inference)), here is an analogy to help you build intuition on how instruction tuning is beneficial: Imagine two university graduates with the same final grade. One is freshly out of university without any working experience, while the other has completed several internships during their breaks. When asked on their first day of work to write meeting minutes, the graduate who only attended university classes will likely write down what happened in the meeting. In contrast, the one with internship experience, having written meeting minutes before, will likely structure the minutes in a better way, noting action items, tasks, and timelines in a well-organized way.</p>
<p>The former corresponds to a foundation model, being well-educated but inexperienced. The latter received the same pre-training but was also instruction-tuned during internships. Hence, the latter knows on day one what is expected when asked to perform certain tasks. Similarly, instruction-tuned language models have seen tasks and their expected outcomes, therefore they do not require few-shot examples to perform such tasks. Additionally, overall zero-shot performance increases because the models have gained a broader understanding of how tasks should be performed.</p>
<p>Instruction Tuning is probably the least-talked about phase of LLM training, but it lays the foundation for turning foundation models into assistants. Further fine-tuning is, however, needed to create an experience like ChatGPT, namely reinforcement learning by human feedback (RLHF).</p>
</section>
<section id="step-3-reinforcement-learning-by-human-feedback-rlhf" class="level2">
<h2 class="anchored" data-anchor-id="step-3-reinforcement-learning-by-human-feedback-rlhf">Step 3: Reinforcement Learning by Human Feedback (RLHF)</h2>
<p>Reinforcement learning by human feedback (RLHF) is the final training stage in creating chatbots like ChatGPT. It helps to further align the model to human preferences and improve instruction following and overall quality. The following chart from the <a href="https://arxiv.org/abs/2307.09288">Llama2 paper</a> [3] shows the full training flow. We have already discussed pre-training, resulting in the foundation model Llama 2. In the paper, instruction tuning (labeled as “supervised fine-tuning”) and RLHF are combined into “fine-tuning,” but you can clearly see that instruction tuning precedes the RLHF phase. The result of instruction tuning is a first version of Llama 2-Chat, which is iteratively fine-tuned with RLHF:</p>
<style>
  figure {
    display: block;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
  }
</style>
<figure class="figure">
<img src="llama2-training-flow.png" alt="How Llama2 was trained, illustration from the Llama2 paper" style="width:100%;" class="figure-img">
<figcaption class="figure-caption">
How Llama2 was trained, illustration from the <a href="https://arxiv.org/abs/2307.09288">Llama2 paper</a>
</figcaption>
</figure>
<p>The Llama2 paper describes the RLHF process as follows. First, a human annotator writes a prompt, and the model generates two responses (A and B). Subsequently, the annotator then ranks the responses in two dimensions:</p>
<ul>
<li>Helpfulness / Overall Preference: The annotator chooses which response is better on a scale of “significantly better,” “better,” “slightly better,” or “negligibly better/unsure.”</li>
<li>Safety: The annotator assesses whether each response is safe or not, considering guidelines about harmful or unsafe content.</li>
</ul>
<p>These labels are not directly used to give feedback to the model on its performance. Instead they are used to train two reward models, one for helpfulness and one for safety. Using two reward models is a design choice by Meta, and the paper makes a compelling argument that balancing the two is challenging. Safe responses (“Sorry, I cannot help you with this request”) may not be helpful, while helpful responses (“Here is how you can destroy humanity in 3 easy steps”) might not be safe. The reward models have the same architecture as the foundation model but they have been trained via transfer learning not to generate the next token for a prompt but to output a scalar value (a number) to rank the prompt for their respective dimension, hence learning human preference. Determining the scalar is just a regression task. The reward score is an important input variable for the reinforcement learning process because it encodes the human preference, therefore turning the reinforcement learning process into RLHF. The actual reinforcement learning is implemented via <a href="https://en.wikipedia.org/wiki/Proximal_policy_optimization">Proximal Policy Optimization (PPO)</a>.</p>
<p>Following the flow of the chart above, the iterative fine-tuning of the model is not done based on the responses selected and scored by humans but on a different thread. The model responses for further fine-tuning are ranked and selected by “Rejection Sampling” and “Proximal Policy Optimization” (PPO). Rejection Sampling might better be called “Best Response Selection,” but the term has its roots in statistics. In this context, rejection sampling means that the model responses are ranked by the reward models’ scores. Responses that are below a certain threshold score are discarded, while those above the threshold are used for further training.</p>
<p>Proximal Policy Optimization (PPO) is a mechanism from reinforcement learning that allows systems to update their policy based on rewards. Oversimplified, you can think of it like lane keeping in autonomous driving. If the model keeps the car centered in the lane, it is rewarded, reinforcing its policy (i.e.&nbsp;its neural net parameters). If the model tends to exit the lane, it is punished, allowing it to update the policy. In the context of large language model training, the loss function of the chat model is replaced with a PPO loss function. This PPO loss function has the following input parameters:</p>
<ul>
<li>The prediction of the chat model. In this context, the parameters of the neural net that generated the response are called the policy.</li>
<li>The reward scores from the reward models</li>
<li>From the generated response and the reward scores, a so-called “advantage” is calculated, which describes how much better or worse the generation is compared to a defined baseline. Reusing the lane-keeping example, the advantage determines where in the lane the generated response is, right in the middle of the lane or drifting out of the lane.</li>
</ul>
<p>By replacing the loss function used in previous learning stages with the PPO loss function, the model can generate the forward pass during prediction and calculate a loss that includes injected parameters of human preference. During backpropagation, the gradients can flow back into the model, updating the model parameters with human preference.</p>
<p>If all of this was too technical and complicated, let’s revisit the analogy of the university graduate being asked to write meeting minutes on their first day of work. Even the one with previous internship experience will most likely not write perfect meeting minutes. Instead, following up on the first meetings, an experienced colleague will (hopefully) review the meeting minutes with the graduate to provide feedback on how meeting minutes are specifically written at their company, which elements should be expanded, noted in a different format, etc. This iterative feedback corresponds to RLHF, during which a language model is further aligned with human expectations through multiple rounds of feedback from human reviewers. The feedback is quantified into rewards, which the model uses to adjust its behavior, improving overall response quality, aligning to human preferences, and adopting safety standards.</p>
</section>
<section id="summary-of-steps-1-to-3" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-steps-1-to-3">Summary of Steps 1 to 3</h2>
<p>Let’s recap the key points of the training stages of large language models to start wrapping up this blog post. The first step in large language model training is self-supervised pre-training, during which a randomly initialized model learns from scratch without any human supervision. We have discussed how pre-training works and built up some intuition on how a model can learn not only grammar and syntax but also semantics and how a model can gain real-world knowledge. Instruction tuning transitions the model from mere text completion into an assistant. By baking in instructions and problem-solving skills, this phase also reduces the need for giving instructions/examples to the model. To put this in different words, the model’s zero-shot performance increases by learning few-shot variants during instruction tuning. Finally, reinforcement learning by human feedback (RLHF) aligns the model with human preferences and further improves performance to create an experience like ChatGPT.</p>
<p>For a more detailed summary, here is a table comparing the three different types of models created by the different training stages.</p>
<table class="table">
<colgroup>
<col style="width: 13%">
<col style="width: 27%">
<col style="width: 29%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Feature/Aspect</th>
<th>Foundation Models</th>
<th>Instruction-Tuned Models</th>
<th>Chat Models</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Purpose</td>
<td>General language understanding and generation</td>
<td>Enhanced understanding of specific instructions</td>
<td>Optimized for interactive and coherent dialogues</td>
</tr>
<tr class="even">
<td>Text Completion</td>
<td>Capable of completing or continuing a given piece of text</td>
<td>Can provide task-specific completions and instructions</td>
<td>Focused on generating coherent replies in a dialogue</td>
</tr>
<tr class="odd">
<td>Example Model</td>
<td>GPT-3 (pre-trained)</td>
<td>GPT-3 (InstructGPT variant)</td>
<td>GPT-3 (ChatGPT)</td>
</tr>
<tr class="even">
<td>Training Data</td>
<td>Diverse, large-scale text data</td>
<td>Task-specific instructions and prompts</td>
<td>Self-generated responses and reward scores based on human feedback</td>
</tr>
<tr class="odd">
<td>Training Method</td>
<td>Self-supervised learning</td>
<td>Supervised learning</td>
<td>Reinforcement learning by human feedback (RLHF)</td>
</tr>
<tr class="even">
<td>Training Effort (Computation)</td>
<td>Extremely high, requires massive computational resources</td>
<td>High, significant but less than initial pre-training</td>
<td>High, significant due to continuous tuning</td>
</tr>
<tr class="odd">
<td>Iteration Cycle</td>
<td>Long, major updates are infrequent</td>
<td>Moderate, updates occur as needed for new tasks</td>
<td>Frequent, continuous updates for improvement</td>
</tr>
<tr class="even">
<td>Alignment / AI Safety</td>
<td>General ethical considerations</td>
<td>Ethical alignment with specific tasks in mind</td>
<td>High focus on ethical AI, safety, and alignment</td>
</tr>
<tr class="odd">
<td>Interactivity</td>
<td>Low, not specifically designed for interactivity</td>
<td>Moderate, responds to specific tasks/instructions</td>
<td>High, designed for dynamic and interactive conversations</td>
</tr>
<tr class="even">
<td>Use Cases</td>
<td>Broad, including text generation, summarization, translation</td>
<td>Task-specific applications like question answering, summarization</td>
<td>Customer service, virtual assistants, interactive chatbots</td>
</tr>
</tbody>
</table>
</section>
<section id="step-4-optional-rag-or-additional-fine-tuning" class="level2">
<h2 class="anchored" data-anchor-id="step-4-optional-rag-or-additional-fine-tuning">Step 4 (optional): RAG or Additional Fine Tuning</h2>
<p>While steps 0 to 3 create extremely useful and knowledgeable models, there is still room for improvement. Depending on the use case, you might choose to enhance model performance by using one of the following techniques:</p>
<ul>
<li><p>Retrieval Augmented Generation (RAG): The knowledge of large language models is limited to their (extensive) training data. If you ask out-of-domain questions, you either do not get an answer, or the model starts to hallucinate. RAG is a technique that gives the model access to additional data sources, grounding it in data relevant to the prompt. RAG typically involves semantic matching of the prompt with the content of a vector database. In a <a href="https://chrwittm.github.io/posts/2024-03-22-rag1-remembering-world-trip/">previous blog post</a>, I implemented a simple RAG scenario that gives a llama2 model access to the blog my wife and I wrote about our world trip in 2017/2018. Since we are talking about how models are trained, it is important to note that RAG is not a training technique that updates the model itself, i.e., the model parameters. RAG is “just” a sophisticated method for in-context learning.</p></li>
<li><p>Fine-Tuning: Chat models can be fine-tuned via additional training runs. Unlike RAG, which gives a model access to additional data, fine-tuning can be deployed to teach additional skills to large language models. The training methods are the same as those we have discussed before. Examples of such fine-tuning include training a large language model on proprietary datasets, for example, company-specific documents to make the model a better assistant for customer service or technical support.</p></li>
</ul>
</section>
<section id="conclusion-large-language-models-are-trained-in-5-steps" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-large-language-models-are-trained-in-5-steps">Conclusion: Large Language Models are Trained in 5 Steps</h2>
<p>We started with the ULMFiT paper, transferred the learning approach to today’s large language models, and discovered that the three steps of the ULMFiT paper are still visible in today’s training approaches, but that the techniques of the different phases have changed in the meantime. We also mentioned two additional steps. Training a tokenizer is a necessary initial step before pre-training can start, because all subsequent training steps are performed on tokenized data. Additional fine-tuning or RAG are optional final steps. The interesting point to make is that steps 0 to 3 are almost exclusively done by large organizations because of the massive datasets and compute required for these steps. Step 4 is the primary way you can customize a large language model. Therefore, for AI practitioners, it is essential to understand the inner mechanics of large language models to choose the right tools for improving model performance.</p>
<p>In closing, the final diagram shows all the five phases which are relevant for training large language models.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<div>
<pre class="mermaid mermaid-js">sequenceDiagram
    participant DP as Data Provider
    participant TP as Training Pipeline
    participant Human as Human Annotator

    %% Step 0: Tokenization
    Note over DP,TP: Step 0: Tokenization
    DP -&gt;&gt; TP: Provide Large General-Domain Corpus for Tokenization
    TP --&gt;&gt; DP: Return Vocabulary for Tokenizer

    %% Step 1: Language Model Pre-Training
    Note over DP,TP: Step 1: Language Model Pre-Training
    DP -&gt;&gt; TP: Provide Large General-Domain Corpus for Pre-Training
    TP --&gt;&gt; DP: Return Pre-Trained Language Model (Foundation Model)

    %% Step 2: Instruction Tuning
    Note over DP,TP: Step 2: Instruction Tuning
    DP -&gt;&gt; TP: Provide Instruction-Focused Corpus for Fine-Tuning
    TP --&gt;&gt; DP: Return Instruction-Tuned Language Model (Assistant Model)

    %% Step 3: Reinforcement Learning with Human Feedback (RLHF)
    Note over DP,Human: Step 3: Reinforcement Learning with Human Feedback (RLHF)
    DP -&gt;&gt; TP: Prompting Instruction-Tuned Language Model
    TP -&gt;&gt; Human: Provide Generated Outputs for Feedback
    Human -&gt;&gt; TP: Provide Feedback on Model Outputs
    TP --&gt;&gt; DP: Return RLHF-Tuned Language Model (Chat Model)

    %% Optional Step 4: Additional Fine-Tuning
    Note over DP,TP: Optional Step 4: Additional Fine-Tuning
    DP -&gt;&gt; TP: Provide Own Dataset for Fine-Tuning
    TP --&gt;&gt; DP: Return Fine-Tuned Language Model (Custom Chat Model)
</pre>
</div>
</div>
</div>
</div>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>[1] Howard, J. (2023). <a href="https://youtu.be/jkrNMKz9pWU?si=88WgZx2u3HaldCgj">A Hackers’ Guide to Language Models</a></p>
<p>[2] Howard, J., &amp; Ruder, S. (2018). <a href="https://arxiv.org/abs/1801.06146">Universal Language Model Fine-tuning for Text Classification</a></p>
<p>[3] Touvron, H., Lavril, T., Izacard, G., Martinet, X., Lachaux, M.-A., Lacroix, T., Rozière, B., Goyal, N., Hambro, E., Azhar, F., Rodriguez, A., Joulin, A., Grave, E., &amp; Lample, G. (2023). <a href="https://arxiv.org/abs/2307.09288">Llama 2: Open Foundation and Fine-Tuned Chat Models</a></p>
<p>[4] Karpathy, A. (2023). <a href="https://youtu.be/zjkBMFhNj_g?si=22yHD6Y0j7hI28sc">Intro to Large Language Models</a></p>
<p>[5] Grant Sanderson (3Blue1Brown). (2024). <a href="https://www.youtube.com/watch?v=wjZofJX0v4M">But what is a GPT? Visual intro to transformers</a></p>
<p>[6] Karpathy, A. (2024). <a href="https://youtu.be/zduSFxRajkE?si=eOf5uPqkOuKLELPe">Let’s build the GPT Tokenizer</a> by Andrej Karpathy</p>
<p>[7] Touvron, H., Izacard, G., Joulin, A., &amp; Lample, G. (2023). <a href="https://arxiv.org/abs/2302.13971">LLaMA: Open and Efficient Foundation Language Models</a></p>
<p>[8] Grant Sanderson (3Blue1Brown). (2024). <a href="https://www.youtube.com/watch?v=eMlx5fFNoYc">Attention in transformers, visually explained</a> by 3Blue1Brown</p>
<p>[9] Wei, J., Bosma, M., Zhao, V. Y., Guu, S., Yu, A. W., Lester, B., Du, N., Dai, A. M., &amp; Le, Q. V. (2021). <a href="https://arxiv.org/abs/2109.01652">Finetuned Language Models Are Zero-Shot Learners</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="chrwittm/chrwittm.github.io.comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center"><div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>